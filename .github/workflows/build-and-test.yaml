#
#  Copyright 2017-2022 Davide Bettio <davide@uninstall.it>
#
#  SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later
#

name: Build and Test

on:
  push:
    paths-ignore:
      - "src/platforms/emscripten/**"
      - "src/platforms/esp32/**"
      - "src/platforms/rp2/**"
      - "src/platforms/stm32/**"
      - "doc/**"
      - "LICENSES/**"
      - "*.Md"
      - "*.md"
  pull_request:
    paths-ignore:
      - "src/platforms/emscripten/**"
      - "src/platforms/esp32/**"
      - "src/platforms/rp2/**"
      - "src/platforms/stm32/**"
      - "doc/**"
      - "LICENSES/**"
      - "*.Md"
      - "*.md"

concurrency:
  group: ${{ github.workflow }}-${{ github.ref != 'refs/heads/main' && github.ref || github.run_id }}
  cancel-in-progress: true

jobs:
  build-and-test:
    runs-on: ubuntu-24.04-arm

    steps:
      - name: Test ARM64 endianness issue with float parsing
        run: |
          cat << 'EOF' > test_endianness_bug.c
          #include <stdio.h>
          #include <math.h>
          #include <stdint.h>
          #include <string.h>

          // Mimic AtomVM's READ_64_UNALIGNED macro behavior
          #if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
              // On little-endian systems (like ARM64), AtomVM incorrectly uses byte swapping
              #define READ_64_UNALIGNED_ATOMVM(ptr) \
                  __builtin_bswap64(*((uint64_t *) (ptr)))
          #else
              // On big-endian systems, it reads correctly
              #define READ_64_UNALIGNED_ATOMVM(ptr) \
                  ( (((uint64_t) ((uint8_t *)(ptr))[0]) << 56) | (((uint64_t) ((uint8_t *) (ptr))[1]) << 48) | \
                    (((uint64_t) ((uint8_t *)(ptr))[2]) << 40) | (((uint64_t) ((uint8_t *) (ptr))[3]) << 32) | \
                    (((uint64_t) ((uint8_t *)(ptr))[4]) << 24) | (((uint64_t) ((uint8_t *) (ptr))[5]) << 16) | \
                    (((uint64_t) ((uint8_t *)(ptr))[6]) << 8) | (((uint64_t) ((uint8_t *) (ptr))[7])) )
          #endif

          // Correct way to read IEEE 754 double from big-endian BEAM format
          #define READ_64_CORRECT(ptr) \
              ( (((uint64_t) ((uint8_t *)(ptr))[0]) << 56) | (((uint64_t) ((uint8_t *) (ptr))[1]) << 48) | \
                (((uint64_t) ((uint8_t *)(ptr))[2]) << 40) | (((uint64_t) ((uint8_t *) (ptr))[3]) << 32) | \
                (((uint64_t) ((uint8_t *)(ptr))[4]) << 24) | (((uint64_t) ((uint8_t *) (ptr))[5]) << 16) | \
                (((uint64_t) ((uint8_t *)(ptr))[6]) << 8) | (((uint64_t) ((uint8_t *) (ptr))[7])) )

          void print_bits(uint64_t bits, const char* label) {
              printf("%s: 0x%016llX = ", label, (unsigned long long)bits);
              for (int i = 63; i >= 0; i--) {
                  printf("%d", (int)((bits >> i) & 1));
                  if (i == 63 || i == 52) printf(" ");
              }
              printf("\n");
          }

          void test_float_parsing(double original_value) {
              printf("\n=== Testing %.1f ===\n", original_value);
              
              // Get the IEEE 754 bit representation
              uint64_t ieee754_bits;
              memcpy(&ieee754_bits, &original_value, sizeof(ieee754_bits));
              print_bits(ieee754_bits, "Original IEEE 754");
              
              // Simulate how BEAM stores it (big-endian format)
              uint8_t beam_bytes[8];
              beam_bytes[0] = (ieee754_bits >> 56) & 0xFF;
              beam_bytes[1] = (ieee754_bits >> 48) & 0xFF;
              beam_bytes[2] = (ieee754_bits >> 40) & 0xFF;
              beam_bytes[3] = (ieee754_bits >> 32) & 0xFF;
              beam_bytes[4] = (ieee754_bits >> 24) & 0xFF;
              beam_bytes[5] = (ieee754_bits >> 16) & 0xFF;
              beam_bytes[6] = (ieee754_bits >> 8) & 0xFF;
              beam_bytes[7] = ieee754_bits & 0xFF;
              
              printf("BEAM bytes: ");
              for (int i = 0; i < 8; i++) {
                  printf("%02X ", beam_bytes[i]);
              }
              printf("\n");
              
              // Test correct parsing
              uint64_t correct_bits = READ_64_CORRECT(beam_bytes);
              double correct_value;
              memcpy(&correct_value, &correct_bits, sizeof(correct_value));
              print_bits(correct_bits, "Correct parsing  ");
              printf("Correct value: %.17g -> llround = %lld\n", correct_value, llround(correct_value));
              
              // Test AtomVM's incorrect parsing on little-endian
              uint64_t atomvm_bits = READ_64_UNALIGNED_ATOMVM(beam_bytes);
              double atomvm_value;
              memcpy(&atomvm_value, &atomvm_bits, sizeof(atomvm_value));
              print_bits(atomvm_bits, "AtomVM parsing   ");
              printf("AtomVM value: %.17g -> llround = %lld\n", atomvm_value, llround(atomvm_value));
              
              if (correct_value != atomvm_value) {
                  printf("*** BUG DETECTED: AtomVM parsing differs from correct parsing! ***\n");
                  printf("*** This explains why round(-2.5) fails on ARM64! ***\n");
              }
          }

          int main() {
              printf("=== ARM64 Endianness Bug Test ===\n");
              printf("Architecture: %s\n", 
                     #ifdef __aarch64__
                     "ARM64"
                     #elif defined(__x86_64__)
                     "x86_64"
                     #else
                     "Unknown"
                     #endif
              );
              
              printf("Byte order: %s\n",
                     #if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
                     "Little Endian"
                     #elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
                     "Big Endian"
                     #else
                     "Unknown"
                     #endif
              );
              
              // Test the problematic value -2.5
              test_float_parsing(-2.5);
              
              // Test other values that might be affected
              test_float_parsing(-1.5);
              test_float_parsing(2.5);
              
              // Test the exact IEEE 754 representation of -2.5
              printf("\n=== Direct IEEE 754 bit test ===\n");
              uint64_t minus_2_5_bits = 0xC004000000000000ULL;  // -2.5 in IEEE 754
              double minus_2_5;
              memcpy(&minus_2_5, &minus_2_5_bits, sizeof(minus_2_5));
              printf("IEEE 754 0xC004000000000000 = %.17g -> llround = %lld\n", 
                     minus_2_5, llround(minus_2_5));
              
              // Test what happens when we byte-swap this
              uint64_t swapped_bits = __builtin_bswap64(minus_2_5_bits);
              double swapped_value;
              memcpy(&swapped_value, &swapped_bits, sizeof(swapped_value));
              printf("Byte-swapped 0x%016llX = %.17g -> llround = %lld\n", 
                     (unsigned long long)swapped_bits, swapped_value, llround(swapped_value));
              
              if (llround(minus_2_5) != llround(swapped_value)) {
                  printf("*** CONFIRMED: Byte swapping changes rounding result! ***\n");
              }
              
              return 0;
          }
          EOF
          
          gcc test_endianness_bug.c -o test_endianness_bug -lm
          ./test_endianness_bug
